Check rapide (T-SQL) pour voir pourquoi √ßa ne baisse pas
A) Voir taille et espace libre par fichier tempdb
Sql
Copier le code
USE tempdb;
SELECT
  name, type_desc,
  size_mb = (size * 8) / 1024,
  used_mb = (FILEPROPERTY(name, 'SpaceUsed') * 8) / 1024,
  free_mb = ((size - FILEPROPERTY(name, 'SpaceUsed')) * 8) / 1024
FROM sys.database_files
ORDER BY type_desc, name;
B) Voir qui consomme tempdb (top cat√©gories)
Sql
Copier le code
SELECT
  SUM(user_object_reserved_page_count)*8/1024.0 AS user_objects_MB,
  SUM(internal_object_reserved_page_count)*8/1024.0 AS internal_objects_MB,
  SUM(version_store_reserved_page_count)*8/1024.0 AS version_store_MB,
  SUM(unallocated_extent_page_count)*8/1024.0 AS free_space_MB,
  SUM(mixed_extent_page_count)*8/1024.0 AS mixed_extents_MB
FROM sys.dm_db_file_space_usage;
C) Voir si version store te bloque
Sql
Copier le code
SELECT
  vs_active = SUM(version_store_reserved_page_count)*8/1024.0
FROM sys.dm_db_file_space_usage;

SELECT TOP (20)
  transaction_id, elapsed_time_seconds, is_snapshot, session_id
FROM sys.dm_tran_active_snapshot_database_transactions
ORDER BY elapsed_time_seconds DESC;
Le cas particulier tempdb : la vraie m√©thode pour r√©duire
‚û°Ô∏è Le seul moyen ‚Äúpropre‚Äù et fiable de faire redescendre tempdb, c‚Äôest :
Configurer la taille voulue (ALTER DATABASE ‚Ä¶ MODIFY FILE)
Red√©marrer l‚Äôinstance SQL Server (tempdb est recr√©√©e au d√©marrage)
Ex :
Sql
Copier le code
ALTER DATABASE tempdb MODIFY FILE (NAME = tempdev, SIZE = 8192MB);
ALTER DATABASE tempdb MODIFY FILE (NAME = tempdev2, SIZE = 8192MB);
-- etc.
Puis restart.
√Ä √©viter (important)
Shrink tempdb r√©guli√®rement = mauvaise pratique (fragmentation + regrowth + perf).
Mieux : dimensionner tempdb correctement (size fixe + autogrowth raisonnable) et traiter la cause (requ√™tes, index rebuild, version store‚Ä¶).
Si tu me donnes :
la sortie de A + B,
le nombre de fichiers tempdb + leurs tailles,
je te dis pr√©cis√©ment si c‚Äôest version store, internal objects, #temp, ou un high-water mark sur un fichier sp√©cifique ‚Äî et quoi faire sans casser la prod.





Oui ‚Äî pour savoir si ‚Äú√ßa bloque en fin de fichier‚Äù, il faut regarder le High-Water Mark (la derni√®re page allou√©e) par fichier tempdb. Si la derni√®re allocation est proche de la fin du fichier, SHRINKFILE ne pourra quasiment rien rendre.
1) M√©thode la plus simple : DBCC SHOWFILESTATS
√áa te donne la derni√®re page utilis√©e ( UsedExtents / LastPage selon versions) et la taille.
Sql
Copier le code
USE tempdb;
DBCC SHOWFILESTATS;
Interpr√©tation :
TotalExtents = taille du fichier (en extents)
UsedExtents = extents utilis√©s (‚âà HWM) ‚û°Ô∏è Si UsedExtents est tr√®s proche de TotalExtents, ton HWM est ‚Äúen fin de fichier‚Äù ‚Üí shrink bloqu√©.
Remarque : l‚Äôoutput exact varie selon versions, mais l‚Äôid√©e reste : comparer ‚Äúused‚Äù vs ‚Äútotal‚Äù.
2) M√©thode pr√©cise : sys.dm_db_database_page_allocations
Tu r√©cup√®res la page allou√©e la plus haute par fichier (HWM r√©el). (OK sur SQL Server r√©cents)
Sql
Copier le code
USE tempdb;
;WITH a AS
(
  SELECT
    allocated_page_file_id AS file_id,
    allocated_page_page_id AS page_id
  FROM sys.dm_db_database_page_allocations
  (
    DB_ID('tempdb'), NULL, NULL, NULL, 'LIMITED'
  )
  WHERE allocated_page_page_id IS NOT NULL
)
SELECT
  file_id,
  max_page_id = MAX(page_id),
  -- conversion approx page -> MB : 8KB/page
  hwm_mb = MAX(page_id) * 8.0 / 1024
FROM a
GROUP BY file_id
ORDER BY file_id;
Puis compare au taille du fichier :
Sql
Copier le code
USE tempdb;
SELECT
  file_id,
  name,
  size_mb = size*8/1024.0
FROM sys.database_files
WHERE type_desc='ROWS'
ORDER BY file_id;
üîé Lecture :
si hwm_mb est ~ √©gal √† size_mb ‚Üí allocations ‚Äúau bout‚Äù ‚Üí shrink quasi impossible
si hwm_mb est nettement plus bas que size_mb ‚Üí shrink devrait pouvoir r√©duire (sinon autre blocage)
3) V√©rifier si tu as du ‚Äúvide‚Äù mais pas √† la fin
Ce cas = beaucoup de free, mais au milieu.
Sql
Copier le code
USE tempdb;
SELECT
  total_mb = SUM(size)*8/1024.0,
  used_mb  = SUM(FILEPROPERTY(name,'SpaceUsed'))*8/1024.0,
  free_mb  = SUM(size - FILEPROPERTY(name,'SpaceUsed'))*8/1024.0
FROM sys.database_files
WHERE type_desc='ROWS';
‚û°Ô∏è Si free_mb est gros mais HWM est haut, √ßa confirme : vide non contigu en fin, donc shrink ne rend pas.
4) Si HWM est haut : trouver le ‚Äúcoupable‚Äù (tempdb)
Le plus fr√©quent sur tempdb : version store ou internal objects.
Sql
Copier le code
SELECT
  user_objects_MB    = SUM(user_object_reserved_page_count)*8/1024.0,
  internal_objects_MB= SUM(internal_object_reserved_page_count)*8/1024.0,
  version_store_MB   = SUM(version_store_reserved_page_count)*8/1024.0
FROM sys.dm_db_file_space_usage;
version_store_MB √©lev√© ‚Üí sessions snapshot/RCSI/online ops bloquent
internal_objects_MB √©lev√© ‚Üí sorts/hashes/spools, index rebuild, grosses requ√™tes
user_objects_MB √©lev√© ‚Üí #temp / table variables
Ce qu‚Äôil faut retenir
SHRINKFILE ne peut r√©duire que si l‚Äôespace libre est √† la fin du fichier.
Pour tempdb, si tu veux vraiment la r√©duire de mani√®re fiable : ALTER DATABASE ‚Ä¶ MODIFY FILE (SIZE=‚Ä¶) + restart instance (tempdb est recr√©√©e au d√©marrage).
Si tu colles ici les r√©sultats de :
DBCC SHOWFILESTATS;
les 2 SELECT (tailles fichiers + HWM) je te dis direct quel fichier bloque et si c‚Äôest version store/internal/#temp.


Avec ces chiffres, ce n‚Äôest clairement pas un ‚Äúwater mark en fin de fichier‚Äù qui bloque.
Ce que tes valeurs veulent dire
UsedExtents = 289 extents
‚Üí 289 √ó 64 KB = ~18 MB utilis√©s
TotalExtents = 229 159 extents
‚Üí 229 159 √ó 64 KB = ~14 GB de taille fichier
Donc ton ‚Äúhigh-water mark‚Äù est tr√®s bas (‚âà 18 MB). Dans ce cas, un shrink devrait pouvoir r√©duire facilement.
Si DBCC SHRINKFILE ‚Äúpasse‚Äù mais que la taille ne bouge pas, les causes probables sont ailleurs :
1) Tu as bien shrink‚Ä¶ mais √ßa regonfle tout de suite (autogrowth)
Tr√®s fr√©quent sur tempdb : shrink ‚Üí OK ‚Üí charge tempdb ‚Üí regrowth imm√©diat ‚Üí tu as l‚Äôimpression que √ßa n‚Äôa rien r√©duit.
‚úÖ V√©rifie la taille juste apr√®s la commande :
Sql
Copier le code
USE tempdb;
SELECT name, size_mb = size*8/1024.0, growth, is_percent_growth
FROM sys.database_files
WHERE type_desc='ROWS';
Et check les √©v√©nements de croissance (errorlog) :
Sql
Copier le code
EXEC xp_readerrorlog 0, 1, N'autogrow', NULL;
2) Un job / script remet la taille ‚Äúcomme avant‚Äù
Beaucoup d‚Äôenvironnements ont un job qui fait : ALTER DATABASE tempdb MODIFY FILE (SIZE = ...) ou une proc√©dure ‚Äústandard‚Äù de d√©marrage.
‚úÖ Cherche dans SQL Agent / scripts de d√©marrage :
Jobs avec MODIFY FILE
Proc√©dures de startup
Politique ‚Äútempdb sizing‚Äù
3) Tu shrink sans ‚Äúcible‚Äù utile, ou tu shrink le mauvais fichier
Pour √™tre certain, force une cible claire (ex : 1024 MB) sur chaque fichier :
Sql
Copier le code
USE tempdb;
DBCC SHRINKFILE (tempdev, 1024);
DBCC SHRINKFILE (tempdev2, 1024);
-- etc.
Puis recontr√¥le sys.database_files.
4) Tu regardes la mauvaise ‚Äútaille‚Äù
Il y a 3 notions :
size dans sys.database_files (taille SQL)
taille du fichier sur disque
espace libre interne (SpaceUsed)
‚úÖ La v√©rit√© SQL = sys.database_files.size.
Si √ßa baisse l√†, le shrink a bien r√©duit.
Le test ‚Äúimparable‚Äù
Fais dans la m√™me minute :
Sql
Copier le code
USE tempdb;
SELECT GETDATE() AS t, name, size_mb = size*8/1024.0
FROM sys.database_files
WHERE type_desc='ROWS';

DBCC SHRINKFILE (tempdev, 1024);

SELECT GETDATE() AS t, name, size_mb = size*8/1024.0
FROM sys.database_files
WHERE type_desc='ROWS';
Si √ßa baisse puis remonte ‚Üí autogrowth / charge
Si √ßa ne baisse jamais alors que UsedExtents est √† 289 ‚Üí (rare) job/param√®tre qui impose une taille, ou tu ne shrink pas le bon logical file / pas le bon type
Si tu me colles :
le r√©sultat de SELECT name, size*8/1024.0 ... FROM tempdb.sys.database_files
la commande exacte que tu lances (DBCC SHRINKFILE (...) compl√®te)
je te dis tout de suite lequel des 4 cas c‚Äôest.