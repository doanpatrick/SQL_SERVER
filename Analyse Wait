Analyse des top wait

üîç Analyse des principaux wait_type que tu observes :

üîµ 1. RESOURCE_SEMAPHORE ‚Äî ‚ö†Ô∏è M√©moire insuffisante pour ex√©cuter certaines requ√™tes
	‚Ä¢	Cause fr√©quente : requ√™tes qui demandent beaucoup de m√©moire (ex : hash join, sort)
	‚Ä¢	Solution :
	‚Ä¢	Optimiser les requ√™tes avec plans complexes
	‚Ä¢	Ajouter des indexes ou r√©√©crire les jointures
	‚Ä¢	V√©rifier la configuration m√©moire de l‚Äôinstance
	‚Ä¢	Revoir les statistiques

‚∏ª

üîµ 2. CXPACKET et CXCONSUMER ‚Äî ‚ö†Ô∏è Probl√®me de parall√©lisme
	‚Ä¢	Signifie : certaines requ√™tes parall√®les ont une ex√©cution d√©s√©quilibr√©e
	‚Ä¢	Causes :
	‚Ä¢	Requ√™tes massives sur des tables non index√©es
	‚Ä¢	Plans de requ√™tes avec Parallelism (Repartition Streams)
	‚Ä¢	Solution :
	‚Ä¢	Ajuster le cost threshold for parallelism (ex : 50 au lieu de 5 par d√©faut)
	‚Ä¢	Analyser les requ√™tes avec MAXDOP trop √©lev√©
	‚Ä¢	Ajouter ou ajuster les indexes

‚∏ª

üîµ 3. PAGEIOLATCH_SH ‚Äî ‚ö†Ô∏è Attente de lecture disque
	‚Ä¢	Indique : SQL Server attend des pages lues depuis disque (pas en cache)
	‚Ä¢	Cause probable :
	‚Ä¢	Pas assez de RAM ‚Üí SQL lit depuis le disque
	‚Ä¢	Requ√™tes qui font de gros table scans
	‚Ä¢	Solution :
	‚Ä¢	Ajouter de la m√©moire (RAM)
	‚Ä¢	Mettre en cache les objets critiques
	‚Ä¢	R√©duire les scans via indexes ou r√©√©criture

‚∏ª

üîµ 4. SOS_SCHEDULER_YIELD ‚Äî ‚ö†Ô∏è CPU sous tension
	‚Ä¢	Signifie : SQL Server rend volontairement la main au planificateur car d‚Äôautres threads ont besoin du CPU
	‚Ä¢	C‚Äôest normal en petite dose, inqui√©tant si dans le top 3
	‚Ä¢	Solution :
	‚Ä¢	Analyser les requ√™tes qui consomment beaucoup de CPU
	‚Ä¢	Mettre en place un monitoring de CPU% par requ√™te via Query Store



Explication des principaux wait_type dans ta requ√™te :
	1.	SOS_WORK_DISPATCHER
Attente sur le planificateur de t√¢ches internes (souvent b√©nin, li√© aux threads internes).
	2.	CXCONSUMER
Attente associ√©e au Parallelism, souvent normale sauf si combin√©e avec des CXPACKET anormaux. Ne pas investiguer seul.
	3.	CXPACKET
Tr√®s courant dans les syst√®mes avec ex√©cution parall√®le. Peut indiquer un probl√®me de configuration ou des plans d‚Äôex√©cution non optimaux.
	4.	RESOURCE_SEMAPHORE
Attente de m√©moire pour ex√©cuter une requ√™te. Indique souvent un besoin d‚Äôoptimisation ou un manque de RAM.
	5.	PAGEIOLATCH_SH
Attente de lecture de page depuis le disque. Peut indiquer un probl√®me d‚ÄôI/O disque ou des requ√™tes non optimis√©es.
	6.	SOS_SCHEDULER_YIELD
Thread volontairement mis en attente pour laisser le CPU √† d‚Äôautres threads. Fr√©quent mais en exc√®s, peut indiquer une pression CPU.
	7.	HADR_FILESTREAM_IOMGR_IOCOMPLETION
Sp√©cifique aux environnements AlwaysOn/Availability Groups utilisant FILESTREAM.
	8.	SP_SERVER_DIAGNOSTICS_SLEEP
Attente interne du thread de diagnostic. Normal, pas un probl√®me.
	9.	DIRTY_PAGE_POLL
T√¢che syst√®me surveillant les pages m√©moire modifi√©es. Normalement b√©nin.
	10.	QDS_PERSIST_TASK_MAIN_LOOP_SLEEP
Relatif au Query Store. B√©nin sauf si anormalement √©lev√©.
	11.	ASYNC_NETWORK_IO
Le serveur attend que le client consomme les r√©sultats. Peut indiquer une application lente √† lire les donn√©es.
	12.	IO_COMPLETION, PAGEIOLATCH_EX
D√©lai d‚Äôattente sur des I/O disques. Si fr√©quent, v√©rifier les performances de stockage.
	13.	LATCH_EX
Attente sur des verrous internes de m√©moire. Si √©lev√©, possible contention interne.
	14.	PREEMPTIVE_XE_DISPATCHER
Utilisation du mode pr√©emptif pour certaines t√¢ches syst√®me. B√©nin sauf s‚Äôil bloque d‚Äôautres processus.
	15.	BROKER_EVENTHANDLER, ASYNC_TASK_QUEUE
Li√© au Service Broker. Normal si utilis√©.









performance

-- Requ√™tes les plus co√ªteuses en CPU sur une p√©riode pr√©cise
SELECT 
    qsqt.query_id,
    qt.query_sql_text,
    p.query_plan,
    rs.avg_cpu_time,
    rs.avg_duration,
    rs.execution_type_desc,
    rs.last_execution_time,
    rs.count_executions  -- ‚úÖ correction ici
FROM sys.query_store_query_text qt
JOIN sys.query_store_query qsqt ON qt.query_text_id = qsqt.query_text_id
JOIN sys.query_store_plan p ON qsqt.query_id = p.query_id
JOIN sys.query_store_runtime_stats rs ON p.plan_id = rs.plan_id
JOIN sys.query_store_runtime_stats_interval rsi ON rs.runtime_stats_interval_id = rsi.runtime_stats_interval_id
WHERE rsi.start_time >= DATEADD(HOUR, -2, GETDATE())  -- ‚è±Ô∏è adapte ici si besoin
ORDER BY rs.avg_cpu_time DESC;


Tu peux aussi ajouter un filtre sur une base sp√©cifique si besoin :

AND qsqt.query_id IN (
    SELECT query_id
    FROM sys.query_store_query
    WHERE object_id IN (
        SELECT object_id FROM sys.objects WHERE type IN ('P', 'V', 'FN', 'IF', 'TF') -- proc/view/fonctions
    )
)

-- Requ√™tes ayant chang√© de plan dans les 2 derni√®res heures
WITH PlansParRequete AS (
    SELECT 
        q.query_id,
        qt.query_sql_text,
        COUNT(DISTINCT p.plan_id) AS nb_plans,
        MAX(rs.last_execution_time) AS derniere_execution
    FROM sys.query_store_query_text qt
    JOIN sys.query_store_query q ON qt.query_text_id = q.query_text_id
    JOIN sys.query_store_plan p ON q.query_id = p.query_id
    JOIN sys.query_store_runtime_stats rs ON p.plan_id = rs.plan_id
    JOIN sys.query_store_runtime_stats_interval rsi ON rs.runtime_stats_interval_id = rsi.runtime_stats_interval_id
    WHERE rsi.start_time >= DATEADD(HOUR, -2, GETDATE())  -- ‚è±Ô∏è √† ajuster selon ton besoin
    GROUP BY q.query_id, qt.query_sql_text
)
SELECT 
    query_id,
    query_sql_text,
    nb_plans,
    derniere_execution
FROM PlansParRequete
WHERE nb_plans > 1
ORDER BY derniere_execution DESC;




-- Plan forcing ou plan r√©gress√© (ex. plan plus lent adopt√© r√©cemment)
SELECT 
    q.query_id,
    qt.query_sql_text,
    p.plan_id,
    p.is_forced_plan,
    p.is_regressed_plan,
    rs.avg_duration,
    rs.execution_count,
    rs.last_execution_time
FROM sys.query_store_query_text qt
JOIN sys.query_store_query q ON qt.query_text_id = q.query_text_id
JOIN sys.query_store_plan p ON q.query_id = p.query_id
JOIN sys.query_store_runtime_stats rs ON p.plan_id = rs.plan_id
WHERE rs.last_execution_time >= DATEADD(HOUR, -1, GETDATE())
ORDER BY rs.avg_duration DESC;


-- Bas√© sur les plans encore pr√©sents en cache (DMV)
SELECT TOP 10 
    qs.sql_handle,
    qs.plan_handle,
    st.text AS query_text,
    qp.query_plan,
    qs.execution_count,
    qs.total_worker_time / 1000 AS total_cpu_ms,
    qs.total_elapsed_time / 1000 AS total_duration_ms,
    qs.creation_time,
    qs.last_execution_time
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) st
CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
WHERE qs.last_execution_time >= DATEADD(HOUR, -1, GETDATE())
ORDER BY total_cpu_ms DESC;

***************


-- 1. TOP Waits par type (hors idles)
SELECT 
    TOP 20 wait_type, 
    wait_time_ms / 1000.0 AS wait_time_sec,
    waiting_tasks_count,
    wait_time_ms / NULLIF(waiting_tasks_count, 0) AS avg_wait_time_ms
FROM sys.dm_os_wait_stats
WHERE wait_type NOT IN (
    'CLR_SEMAPHORE','LAZYWRITER_SLEEP','RESOURCE_QUEUE','SLEEP_TASK',
    'SLEEP_SYSTEMTASK','SQLTRACE_BUFFER_FLUSH','WAITFOR','LOGMGR_QUEUE',
    'CHECKPOINT_QUEUE','REQUEST_FOR_DEADLOCK_SEARCH','XE_TIMER_EVENT',
    'BROKER_TO_FLUSH','BROKER_TASK_STOP','CLR_MANUAL_EVENT','CLR_AUTO_EVENT',
    'DISPATCHER_QUEUE_SEMAPHORE','FT_IFTS_SCHEDULER_IDLE_WAIT','XE_DISPATCHER_WAIT',
    'XE_DISPATCHER_JOIN','SQLTRACE_INCREMENTAL_FLUSH_SLEEP')
ORDER BY wait_time_ms DESC;

-- 2. Sessions avec de fortes attentes (waits en cours)
SELECT 
    s.session_id, 
    r.status, 
    r.command, 
    r.wait_type, 
    r.wait_time,
    r.wait_resource,
    r.blocking_session_id,
    r.cpu_time, 
    r.total_elapsed_time,
    s.login_name, 
    s.host_name, 
    s.program_name
FROM sys.dm_exec_requests r
JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
WHERE r.status = 'suspended'
ORDER BY r.wait_time DESC;

-- 3. Blocages actifs (blocking chain)
SELECT 
    session_id, 
    blocking_session_id,
    wait_type, 
    wait_time,
    wait_resource,
    (SELECT TEXT FROM sys.dm_exec_sql_text(sql_handle)) AS query_text
FROM sys.dm_exec_requests
WHERE blocking_session_id <> 0;

-- 4. Contention sur les verrous (verrouillage/lock contention)
SELECT 
    resource_type,
    request_mode,
    request_status,
    COUNT(*) AS request_count
FROM sys.dm_tran_locks
GROUP BY resource_type, request_mode, request_status
ORDER BY request_count DESC;

-- 5. TOP IO Consumers par base et fichier
SELECT 
    DB_NAME(vfs.database_id) AS database_name,
    mf.name AS file_name,
    vfs.num_of_reads, 
    vfs.num_of_writes,
    vfs.io_stall_read_ms, 
    vfs.io_stall_write_ms,
    (vfs.io_stall_read_ms + vfs.io_stall_write_ms) AS total_stall_ms
FROM sys.dm_io_virtual_file_stats(NULL, NULL) vfs
JOIN sys.master_files mf ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
ORDER BY total_stall_ms DESC;

-- Indexes tr√®s lus (potentiellement surcharg√©s ou √† optimiser)
SELECT 
    DB_NAME(s.database_id) AS database_name,
    OBJECT_NAME(s.object_id, s.database_id) AS object_name,
    i.name AS index_name,
    s.user_seeks, 
    s.user_scans, 
    s.user_lookups, 
    s.user_updates,
    (s.user_seeks + s.user_scans + s.user_lookups) AS total_reads
FROM sys.dm_db_index_usage_stats s
JOIN sys.indexes i 
    ON s.object_id = i.object_id 
    AND s.index_id = i.index_id 
    AND s.database_id = DB_ID()  -- facultatif : limite √† la DB courante
WHERE s.database_id = DB_ID()
ORDER BY total_reads DESC;



SELECT
    r.session_id,
    r.status,
    r.wait_type,
    r.wait_time,
    r.command,
    r.cpu_time,
    r.total_elapsed_time,
    r.logical_reads,
    r.writes,
    r.row_count,
    t.text AS sql_text,
    qp.query_plan
FROM sys.dm_exec_requests r
JOIN sys.dm_exec_query_memory_grants mg ON r.session_id = mg.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) qp
WHERE r.wait_type = 'RESOURCE_SEMAPHORE'
ORDER BY r.total_elapsed_time DESC;



analyse attente memoire

SELECT
    r.session_id,
    r.status,
    r.wait_type,
    r.wait_time,
    r.command,
    r.cpu_time,
    r.total_elapsed_time,
    r.logical_reads,
    r.writes,
    r.row_count,
    t.text AS sql_text,
    qp.query_plan
FROM sys.dm_exec_requests r
JOIN sys.dm_exec_query_memory_grants mg ON r.session_id = mg.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
CROSS APPLY sys.dm_exec_query_plan(r.plan_handle) qp
WHERE r.wait_type = 'RESOURCE_SEMAPHORE'
ORDER BY r.total_elapsed_time DESC;

