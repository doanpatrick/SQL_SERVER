Tu parles de SQL Server (SS ğŸ˜Š). Ces 2 options activent le row versioning (versions de lignes) pour Ã©viter que les lectures bloquent les Ã©critures (et inversement), en sâ€™appuyant sur le version store dans tempdb.
1) ALLOW_SNAPSHOT_ISOLATION ON : quâ€™est-ce que Ã§a fait ?
Ã‡a autorise lâ€™usage du niveau dâ€™isolation SNAPSHOT au cas par cas.
Ã‡a ne change rien tout seul au comportement des requÃªtes existantes.
Pour en profiter, une session doit explicitement faire :
Copier le code
Sql
SET TRANSACTION ISOLATION LEVEL SNAPSHOT;
BEGIN TRAN;
-- tes SELECT ici lisent une "photo" cohÃ©rente au dÃ©but de la transaction
COMMIT;
Effet : tes SELECT ne prennent pas de verrous bloquants (pas de blocking cÃ´tÃ© lecture), et lisent une version cohÃ©rente des donnÃ©es.
Attention : en SNAPSHOT, lors dâ€™UPDATE/DELETE, tu peux avoir des conflits dâ€™update (â€œSnapshot isolation transaction aborted due to update conflictâ€¦â€) si quelquâ€™un a modifiÃ© les mÃªmes lignes depuis le dÃ©but de ta transaction.
2) READ_COMMITTED_SNAPSHOT ON (RCSI) : quâ€™est-ce que Ã§a fait ?
Ã‡a modifie le comportement par dÃ©faut de READ COMMITTED (celui de la plupart des applis) :
Avant : READ COMMITTED lit via des verrous partagÃ©s â†’ peut bloquer / Ãªtre bloquÃ©.
Avec RCSI ON : READ COMMITTED lit des versions (row versions) au moment oÃ¹ la requÃªte dÃ©marre â†’ beaucoup moins de blocking lecture/Ã©criture.
ğŸ‘‰ Donc RCSI a un impact fonctionnel potentiel (sÃ©mantique) : une requÃªte peut lire des donnÃ©es â€œun peu plus anciennesâ€ (commitÃ©es avant le dÃ©but de la requÃªte), plutÃ´t que dâ€™attendre les verrous.
3) Lâ€™impact concret sur ta base (Ã  anticiper)
âœ… Les bÃ©nÃ©fices
Moins de blocking entre lecteurs et writers (souvent Ã©norme gain en prod).
Meilleure stabilitÃ© des temps de rÃ©ponse cÃ´tÃ© SELECT.
âš ï¸ Les coÃ»ts / risques
tempdb va stocker des versions de lignes :
plus dâ€™IO tempdb, plus de conso espace, possible growth.
SurcoÃ»t lÃ©ger sur les Ã©critures (INSERT/UPDATE/DELETE) car SQL Server doit gÃ©rer les versions.
Si tu as des transactions longues (reporting, batch, ETL), elles peuvent faire gonfler le version store (les vieilles versions doivent Ãªtre conservÃ©es tant quâ€™une transaction peut en avoir besoin).
En pratique : lâ€™impact â€œmÃ©tierâ€ le plus sensible est RCSI, parce quâ€™il change le comportement par dÃ©faut de READ COMMITTED.
4) Comment vÃ©rifier lâ€™Ã©tat (et ce qui tourne)
Copier le code
Sql
SELECT
    name,
    snapshot_isolation_state_desc,
    is_read_committed_snapshot_on
FROM sys.databases
WHERE name = DB_NAME();
Voir les transactions snapshot actives :
Copier le code
Sql
SELECT *
FROM sys.dm_tran_active_snapshot_database_transactions
WHERE database_id = DB_ID();
Surveillance version store / tempdb (indicateurs utiles) :
Copier le code
Sql
SELECT *
FROM sys.dm_tran_version_store_space_usage
WHERE database_id = DB_ID();
5) â€œRollbackâ€ : comment revenir en arriÃ¨re
Cas A â€” dÃ©sactiver RCSI (le vrai changement par dÃ©faut)
Copier le code
Sql
ALTER DATABASE [TaBase] SET READ_COMMITTED_SNAPSHOT OFF;
âš ï¸ En pratique, Ã§a peut attendre que des transactions finissent, et SQL Server peut demander un accÃ¨s exclusif. En maintenance, on fait souvent :
Copier le code
Sql
ALTER DATABASE [TaBase] SET READ_COMMITTED_SNAPSHOT OFF WITH ROLLBACK IMMEDIATE;
WITH ROLLBACK IMMEDIATE = coupe les sessions/transactions en cours sur la base (Ã  utiliser en fenÃªtre de maintenance).
Cas B â€” retirer lâ€™autorisation SNAPSHOT
Copier le code
Sql
ALTER DATABASE [TaBase] SET ALLOW_SNAPSHOT_ISOLATION OFF;
LÃ  aussi, si des transactions SNAPSHOT sont actives, Ã§a peut attendre. En maintenance :
Copier le code
Sql
ALTER DATABASE [TaBase] SET ALLOW_SNAPSHOT_ISOLATION OFF WITH ROLLBACK IMMEDIATE;
âœ… Ordre conseillÃ© pour â€œrollback completâ€ :
OFF RCSI
OFF ALLOW_SNAPSHOT_ISOLATION
6) Est-ce â€œdangereuxâ€ ?
Pas â€œdangereuxâ€ en soi, câ€™est trÃ¨s courant en prod. Mais il faut surtout :
sâ€™assurer que tempdb est bien dimensionnÃ©e (fichiers, autogrowth raisonnable, stockage),
traquer les transactions longues,
valider que les applis tolÃ¨rent le comportement RCSI (quasi toujours OK, mais certains patterns trÃ¨s spÃ©cifiques peuvent â€œvoirâ€ des donnÃ©es lÃ©gÃ¨rement diffÃ©rentes quâ€™avant).
Si tu me donnes :
version SQL Server,
taille/charge (beaucoup de write ?),
symptÃ´mes (blocking sur quelles tables / quelles requÃªtes), je peux te dire si RCSI est pertinent, et quels compteurs/DMV suivre pour mesurer lâ€™impact (tempdb, version store, blocking, waits).