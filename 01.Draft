Tu verras si c‚Äôest juste lent √† cause du d√©bit disque ou bloqu√© ailleurs.


SELECT 
    session_id, 
    wait_type, 
    wait_time, 
    blocking_session_id,
    percent_complete, 
    estimated_completion_time/1000/60 AS est_completion_min,
    command,
    database_id,
    start_time
FROM sys.dm_exec_requests
WHERE command LIKE 'RESTORE%';



deplacer base SSISDB

BACKUP DATABASE SSISDB TO DISK = 'D:\Backup\SSISDB_before_move.bak' WITH INIT;

SELECT name AS LogicalName, physical_name
FROM sys.master_files
WHERE database_id = DB_ID('SSISDB');

ALTER DATABASE SSISDB SET OFFLINE WITH ROLLBACK IMMEDIATE;

D√©placer physiquement les fichiers sur le disque


ALTER DATABASE SSISDB 
MODIFY FILE (NAME = SSISDB, FILENAME = 'O:\SQLData\SSISDB.mdf');
GO

ALTER DATABASE SSISDB 
MODIFY FILE (NAME = SSISDB_log, FILENAME = 'L:\SQLLogs\SSISDB.ldf');
GO

ALTER DATABASE SSISDB SET ONLINE;

SELECT name, physical_name 
FROM sys.master_files 
WHERE database_id = DB_ID('SSISDB');



*******************

USE master;
GO

-- 1Ô∏è‚É£ V√©rifie les chemins actuels
SELECT name AS LogicalName, physical_name
FROM sys.master_files
WHERE database_id = DB_ID('SSISDB');
GO

-- 2Ô∏è‚É£ Met la base hors ligne (arr√™te imm√©diatement les connexions)
ALTER DATABASE SSISDB SET OFFLINE WITH ROLLBACK IMMEDIATE;
GO


-- 3Ô∏è‚É£ Met √† jour les chemins physiques dans SQL Server
ALTER DATABASE SSISDB 
MODIFY FILE (NAME = SSISDB, FILENAME = 'K:\SQLData\SSISDB.mdf');
GO

ALTER DATABASE SSISDB 
MODIFY FILE (NAME = SSISDB_log, FILENAME = 'L:\SQLLogs\SSISDB_log.ldf');
GO

-- 4Ô∏è‚É£ Remet la base en ligne
ALTER DATABASE SSISDB SET ONLINE;
GO

SELECT name AS LogicalName, physical_name
FROM sys.master_files
WHERE database_id = DB_ID('SSISDB');



voir lez snapshot db

SELECT 
    s.name AS SnapshotName,
    d.name AS SourceDatabase,
    s.create_date,
    s.state_desc
FROM sys.databases s
JOIN sys.databases d ON s.source_database_id = d.database_id
ORDER BY d.name, s.create_date;

perf lcb

1. Historique des attentes de type ‚ÄúLock‚Äù (sur 24 h)

üëâ Cette vue s‚Äôappuie sur sys.dm_os_wait_stats, qui cumule les temps d‚Äôattente depuis le dernier d√©marrage du service SQL Server.
Elle permet de voir quels types de verrous dominent globalement.

-- Attentes LOCK sur les derni√®res 24h (depuis dernier reset)
SELECT 
    wait_type,
    waiting_tasks_count AS NbOccurrences,
    wait_time_ms / 1000.0 AS WaitTime_s,
    (wait_time_ms * 100.0 / SUM(wait_time_ms) OVER()) AS PercentOfTotal
FROM sys.dm_os_wait_stats
WHERE wait_type LIKE 'LCK%'
ORDER BY wait_time_ms DESC;

Lecture :
	‚Ä¢	Si tu vois LCK_M_IS ou LCK_M_IX en t√™te ‚Üí contention sur inserts/updates.
	‚Ä¢	Si LCK_M_S ‚Üí lectures bloqu√©es par transactions longues.
	‚Ä¢	Si LCK_M_RS_S ‚Üí verrouillage de plage d‚Äôindex (souvent sur requ√™tes avec BETWEEN, LIKE, etc.).

‚∏ª

üìà 2. Top 10 requ√™tes historiques avec attente ‚ÄúLock‚Äù

üëâ Celle-ci va chercher dans sys.dm_exec_query_stats toutes les requ√™tes ayant accumul√© du temps d‚Äôattente sur les verrous.
Elle te permet d‚Äôidentifier les requ√™tes les plus bloquantes, m√™me si elles ne tournent plus √† l‚Äôinstant T.

-- Requ√™tes ayant accumul√© le plus de LOCK waits depuis le dernier d√©marrage
SELECT TOP 10
    DB_NAME(st.dbid) AS DatabaseName,
    SUBSTRING(st.text, (qs.statement_start_offset/2)+1,
        ((CASE qs.statement_end_offset
          WHEN -1 THEN DATALENGTH(st.text)
          ELSE qs.statement_end_offset END
         - qs.statement_start_offset)/2)+1) AS SQLText,
    qs.execution_count,
    qs.total_elapsed_time / 1000.0 AS TotalTime_ms,
    qs.total_worker_time / 1000.0 AS CPUTime_ms,
    qs.total_wait_time / 1000.0 AS WaitTime_ms,
    qs.total_wait_time * 100.0 / qs.total_elapsed_time AS WaitPct,
    qs.total_logical_reads AS LogicalReads,
    qs.total_logical_writes AS LogicalWrites
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
WHERE qs.total_wait_time > 0
ORDER BY qs.total_wait_time DESC;

	‚Ä¢	Le champ WaitPct te montre le poids des attentes dans le temps total.
	‚Ä¢	Tu verras directement les requ√™tes qui cumulent du lock (souvent des INSERT INTO ... ou UPDATE ... WHERE ... sur les m√™mes tables).

‚∏ª

üß© 3. Attentes par base de donn√©es sur 24 h

üëâ Pour savoir quelle base est la plus touch√©e par les locks :

SELECT 
    DB_NAME(database_id) AS DatabaseName,
    SUM(wait_time_ms) / 1000.0 AS WaitTime_s,
    COUNT(*) AS NbWaits,
    AVG(wait_time_ms) / 1000.0 AS AvgWait_s
FROM sys.dm_os_waiting_tasks
WHERE wait_type LIKE 'LCK%'
GROUP BY database_id
ORDER BY WaitTime_s DESC;


4. √âvolution temporelle (approche journali√®re)

üëâ Si tu as activ√© le Query Store, tu peux obtenir l‚Äô√©volution dans le temps des locks :

SELECT 
    qt.query_sql_text,
    rs.last_execution_time,
    rs.avg_wait_time / 1000.0 AS AvgWait_s,
    rs.avg_duration / 1000.0 AS AvgDuration_s,
    rs.count_executions
FROM sys.query_store_runtime_stats AS rs
JOIN sys.query_store_plan AS qp ON rs.plan_id = qp.plan_id
JOIN sys.query_store_query AS qq ON qp.query_id = qq.query_id
JOIN sys.query_store_query_text AS qt ON qq.query_text_id = qt.query_text_id
WHERE rs.last_execution_time > DATEADD(HOUR, -24, GETDATE())
AND rs.avg_wait_time > 0
ORDER BY rs.avg_wait_time DESC;

Cela te montrera :
	‚Ä¢	Quelles requ√™tes ont eu les plus gros temps d‚Äôattente sur 24 h,
	‚Ä¢	Et √† quelle heure elles ont √©t√© ex√©cut√©es (last_execution_time),
‚Üí Tu pourras corr√©ler √ßa avec tes pics de 05 h15 / 08 h20.

‚∏ª

üß∞ 5. Astuce utile : reset des stats pour une fen√™tre propre

Avant de relancer des traitements et observer une nouvelle p√©riode (par exemple demain matin) :

DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);

 Cela vide les compteurs d‚Äôattente et permet de mesurer sur une p√©riode donn√©e (propre, sans bruit historique).

‚∏ª

üîé 6. Lecture finale ‚Äì ce que tu dois retenir


Observation
Interpr√©tation probable
Pics r√©guliers de LCK_M_IS ou LCK_M_IX
Inserts/Updates simultan√©s sur m√™me table ou page
Lock Intent dominant
Forte contention sur hi√©rarchie de verrous (page ‚Üí table)
Attente Lock Shared
Lectures bloqu√©es par transactions non commit
Table r√©currente dans top locks
‚ÄúHot table‚Äù √† partitionner, ou √† traiter par batch
Heures fixes (05 h / 08 h)
Job planifi√© (ETL, int√©gration, middleware) cr√©ant un pic concurrentiel







test partionning sur standard

----------------------------------------------------------
-- 1Ô∏è‚É£ Cr√©ation d'une base de test
----------------------------------------------------------
USE master;
GO
IF DB_ID('PartitionTestDB') IS NOT NULL
BEGIN
    ALTER DATABASE PartitionTestDB SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE PartitionTestDB;
END;
GO

CREATE DATABASE PartitionTestDB;
GO
USE PartitionTestDB;
GO

----------------------------------------------------------
-- 2Ô∏è‚É£ Cr√©ation d'une fonction de partition
----------------------------------------------------------
PRINT '=== Cr√©ation de la fonction de partition ===';
GO
CREATE PARTITION FUNCTION pf_TestRange (int)
AS RANGE LEFT FOR VALUES (1000, 2000, 3000);
GO

----------------------------------------------------------
-- 3Ô∏è‚É£ Cr√©ation d‚Äôun sch√©ma de partition
----------------------------------------------------------
PRINT '=== Cr√©ation du sch√©ma de partition ===';
GO
CREATE PARTITION SCHEME ps_TestRange
AS PARTITION pf_TestRange
ALL TO ([PRIMARY]);
GO

----------------------------------------------------------
-- 4Ô∏è‚É£ Cr√©ation d‚Äôune table partitionn√©e
----------------------------------------------------------
PRINT '=== Cr√©ation de la table partitionn√©e ===';
GO
CREATE TABLE dbo.TestPartition
(
    ID int NOT NULL,
    Col1 varchar(50)
)
ON ps_TestRange(ID);
GO

----------------------------------------------------------
-- 5Ô∏è‚É£ V√©rification du partitionnement
----------------------------------------------------------
PRINT '=== V√©rification du partitionnement ===';
GO
SELECT 
    pf.name AS PartitionFunction,
    ps.name AS PartitionScheme,
    pf.function_id,
    pf.boundary_value_on_right,
    prv.value AS BoundaryValue
FROM sys.partition_functions AS pf
JOIN sys.partition_schemes AS ps ON ps.function_id = pf.function_id
JOIN sys.partition_range_values AS prv ON pf.function_id = prv.function_id
ORDER BY prv.boundary_id;
GO

SELECT 
    object_name(object_id) AS TableName,
    partition_number,
    rows
FROM sys.partitions
WHERE object_id = OBJECT_ID('dbo.TestPartition');
GO


v√©rification user

USE MaBase;
GO
SELECT dp.name AS [DatabaseUser], sp.name AS [LoginName], dp.sid
FROM sys.database_principals dp
LEFT JOIN sys.server_principals sp ON dp.sid = sp.sid
WHERE dp.type IN ('S', 'U')
ORDER BY dp.name;


update level cluster

Tu peux prendre un snapshot/backup de VM avant l‚Äôupgrade OS ou avant la commande Update-ClusterFunctionalLevel (√ßa donne une s√©curit√© suppl√©mentaire).
	‚Ä¢	Les pr√©requis et droits ne changent pas : il te faut √™tre Cluster Admin (et Admin local sur les VMs).

‚∏ª

üìå Exemple concret : 2 n≈ìuds en VM

Situation de d√©part
	‚Ä¢	Cluster Windows Server 2016 (CFL = 9).
	‚Ä¢	Tu as fait l‚Äôupgrade in-place ou rebuild de chaque VM en Windows Server 2019.
	‚Ä¢	Tous les n≈ìuds sont maintenant sous 2019.

‚∏ª

√âtapes pratiques
	1.	V√©rifier la version et le niveau fonctionnel actuel

Get-ClusterNode
Get-Cluster | fl ClusterFunctionalLevel

2.	Contr√¥ler que toutes les VMs sont √† jour (patchs Windows + drivers VM tools)
	‚Ä¢	Si tu es sous VMware : v√©rifier VMware Tools + compatibilit√© hardware version.
	‚Ä¢	Si tu es sous Hyper-V : v√©rifier les integration services.
	3.	Sauvegarde/snapshot
	‚Ä¢	Snapshot des VMs cluster nodes (optionnel mais conseill√©).
	‚Ä¢	Sauvegarde des workloads (SQL, File Share, etc.).
	4.	√âlever le niveau fonctionnel


Update-ClusterFunctionalLevel


Pas de red√©marrage n√©cessaire, mais certaines ressources peuvent bri√®vement basculer (pr√©voir fen√™tre).

	5.	V√©rification post-upgrade

Get-Cluster | fl ClusterFunctionalLevel
Get-ClusterGroup






Parfait üëå
Voici un checklist complet en PowerShell pour ton cas (cluster de VMs d√©j√† migr√©es vers Windows Server 2019/2022). Tu peux l‚Äôutiliser comme script de contr√¥le avant / pendant / apr√®s l‚Äô√©l√©vation du Cluster Functional Level (CFL).

‚∏ª

üü¢ √âtape 1 ‚Äì V√©rifications pr√©alables

# V√©rifier les n≈ìuds du cluster et leur √©tat
Get-ClusterNode | ft Name, State, NodeWeight

# V√©rifier la version de l‚ÄôOS sur chaque n≈ìud
Get-ClusterNode | % { $_.Name + " - " + (Get-CimInstance Win32_OperatingSystem -ComputerName $_.Name).Caption }

# V√©rifier le niveau fonctionnel actuel du cluster
Get-Cluster | fl Name, ClusterFunctionalLevel

# V√©rifier l‚Äô√©tat global du cluster
Test-Cluster

üëâ Ici tu t‚Äôassures :
	‚Ä¢	Tous les n≈ìuds sont Up et en Windows Server 2019/2022.
	‚Ä¢	Le CFL est encore √† l‚Äôancien niveau (ex : 9 si anciennement 2016).
	‚Ä¢	Le Test-Cluster ne remonte pas d‚Äôerreurs bloquantes.

‚∏ª

üü° √âtape 2 ‚Äì Sauvegardes / snapshots (optionnel mais conseill√©)
	‚Ä¢	Snapshot ou clone des VMs cluster nodes.
	‚Ä¢	Sauvegarde des workloads h√©berg√©s (SQL Server, File Server, etc.).

‚∏ª

üîµ √âtape 3 ‚Äì Upgrade du Cluster Functional Level


# Monter le cluster functional level
Update-ClusterFunctionalLevel

‚ö†Ô∏è Cette commande est irr√©versible.
Elle ne red√©marre pas les VMs, mais peut entra√Æner une bascule rapide de r√¥les (pr√©voir une petite fen√™tre).

‚∏ª

üü£ √âtape 4 ‚Äì V√©rifications post-upgrade


# Recontr√¥ler le CFL
Get-Cluster | fl Name, ClusterFunctionalLevel

# V√©rifier les ressources du cluster
Get-ClusterGroup | ft Name, State, OwnerNode

# V√©rifier les disques / volumes
Get-ClusterResource | ? ResourceType -eq "Physical Disk" | ft Name, State, OwnerGroup


üëâ Tu confirmes que :
	‚Ä¢	Le CFL a bien chang√© (10 = 2019, 11 = 2022).
	‚Ä¢	Toutes les ressources sont Online.
	‚Ä¢	Les r√¥les (SQL, File Share, etc.) sont bien h√©berg√©s sur un n≈ìud.

‚∏ª

üü§ √âtape 5 ‚Äì Nettoyage
	‚Ä¢	Supprimer les snapshots VM (apr√®s validation).
	‚Ä¢	Documenter le nouveau CFL.

‚∏ª

üí° Astuce : tu peux ex√©cuter tout √ßa en Remote PowerShell depuis ton poste admin si ton compte est Cluster Admin et Admin local sur les VMs.









voir le filestream

/* ===============================
   Informations FILESTREAM Instance
   =============================== */
SELECT  
    SERVERPROPERTY('InstanceName')       AS InstanceName,
    SERVERPROPERTY('FilestreamShareName') AS FilestreamShareName,
    SERVERPROPERTY('FilestreamConfiguredLevel') AS ConfiguredLevel,
    SERVERPROPERTY('FilestreamEffectiveLevel')  AS EffectiveLevel;

/* ===============================
   Informations FILESTREAM par base
   =============================== */
SELECT  
    db.name              AS DatabaseName,
    fg.name              AS FilegroupName,
    mf.name              AS FileName,
    mf.physical_name     AS PhysicalPath,
    mf.type_desc         AS FileType
FROM sys.master_files mf
JOIN sys.databases db ON db.database_id = mf.database_id
JOIN sys.filegroups fg ON mf.data_space_id = fg.data_space_id
WHERE mf.type = 2   -- 2 = FILESTREAM
ORDER BY db.name, fg.name;

restauration en mode single user sur master

-- V√©rifie d‚Äôabord le backup
RESTORE HEADERONLY FROM DISK = 'D:\Backup\master_full.bak';
RESTORE FILELISTONLY FROM DISK = 'D:\Backup\master_full.bak';

-- Restaure master sur l‚Äôinstance bac √† sable
RESTORE DATABASE master
  FROM DISK = 'D:\Backup\master_full.bak'
  WITH REPLACE;
-- L‚Äôinstance va s‚Äôarr√™ter apr√®s la restauration de master.




voir

-- V√©rifier le propri√©taire actuel vu par master
SELECT name, suser_sname(owner_sid) AS owner_in_master
FROM sys.databases
WHERE name = N'DB_OBB';

-- V√©rifier le dbo √† l'int√©rieur de la base
USE [DB_OBB];
SELECT name, sid, SUSER_SNAME(sid) AS dbo_login_in_db
FROM sys.database_principals
WHERE name = N'dbo';

-- Corriger : remettre un propri√©taire coh√©rent (ex : sa)
ALTER AUTHORIZATION ON DATABASE::[DB_OBB] TO sa;



EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'filestream access level', 2;  -- 0=Off, 1=T-SQL, 2=T-SQL + Win I/O
RECONFIGURE;
SELECT SERVERPROPERTY('FilestreamEffectiveLevel'),
       SERVERPROPERTY('FilestreamShareName');



-- Remplace le chemin par ton MDF
DBCC CHECKPRIMARYFILE ('K:\APP\MSSQL\MSSQL\DATA\BIJOU.mdf', 2);
-- Regarde le nom du FILEGROUP de type FILESTREAM et le nom logique du fichier FILESTREAM




CREATE DATABASE BIJOU
ON
( FILENAME = 'K:\APP\MSSQL\MSSQL\DATA\BIJOU.mdf' ),
( FILENAME = 'K:\APP\MSSQL\MSSQL\LOG\BIJOU_log.ldf' ),
FILEGROUP BIJOU_FS CONTAINS FILESTREAM         -- nom exact du FG FILSTREAM
( NAME = 'BIJOU_FS', FILENAME = 'K:\APP\MSSQL\MSSQL\BIJOU' )  -- <<< le dossier avec filestream.hdr
FOR ATTACH;






voir role et permission



USE NomDeTaBase;
GO

-- 1. Membres du r√¥le sysadmin (niveau instance)
SELECT sp.name AS LoginName,
       sp.type_desc AS LoginType,
       'Serveur' AS Scope,
       'sysadmin' AS Role
FROM sys.server_role_members rm
JOIN sys.server_principals r ON rm.role_principal_id = r.principal_id
JOIN sys.server_principals sp ON rm.member_principal_id = sp.principal_id
WHERE r.name = 'sysadmin';

-- 2. Membres des r√¥les de base importants
SELECT dp.name AS UserName,
       dp.type_desc AS UserType,
       'Base' AS Scope,
       r.name AS Role
FROM sys.database_role_members drm
JOIN sys.database_principals r ON drm.role_principal_id = r.principal_id
JOIN sys.database_principals dp ON drm.member_principal_id = dp.principal_id
WHERE r.name IN ('db_owner','db_datareader','db_datawriter','db_ddladmin');

-- 3. Permissions explicites (CONTROL, ALTER, SELECT, INSERT, UPDATE, DELETE, etc.)
SELECT dp.name AS UserName,
       dp.type_desc AS UserType,
       perm.permission_name,
       perm.state_desc
FROM sys.database_permissions perm
JOIN sys.database_principals dp ON perm.grantee_principal_id = dp.principal_id
WHERE perm.permission_name IN ('CONTROL','ALTER','SELECT','INSERT','UPDATE','DELETE')
  AND perm.state_desc IN ('GRANT_WITH_GRANT_OPTION','GRANT');






mettre un extended event en place

1) Cr√©er + d√©marrer la session (fichiers roulants)

‚ö†Ô∏è Adapte le chemin D:\SqlAudit\ √† un dossier existant o√π le compte SQL Server a les droits.

USE [DB_LDW_FULL];
GO
DECLARE @schema sysname = N'dbo';
DECLARE @table  sysname = N'INS_GDV_GeneriqueDevises';
DECLARE @session sysname = N'WhoWrites_INS_GDV_GeneriqueDevises';

-- Nettoyage si d√©j√† existant
IF EXISTS (SELECT 1 FROM sys.server_event_sessions WHERE name = @session)
BEGIN
  ALTER EVENT SESSION [WhoWrites_INS_GDV_GeneriqueDevises] ON SERVER STATE = STOP;
  DROP EVENT SESSION [WhoWrites_INS_GDV_GeneriqueDevises] ON SERVER;
END
GO

-- Cr√©ation (fichier .xel avec rotation)
CREATE EVENT SESSION [WhoWrites_INS_GDV_GeneriqueDevises] ON SERVER
ADD EVENT sqlserver.sql_statement_completed(
    ACTION(sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.database_name,
           sqlserver.session_id,sqlserver.username)
    WHERE ( sqlserver.database_name = DB_NAME()
         AND ( statement LIKE N'%INSERT%['+N'dbo'+'].['+N'INS_GDV_GeneriqueDevises'+']%'
            OR statement LIKE N'%UPDATE%['+N'dbo'+'].['+N'INS_GDV_GeneriqueDevises'+']%'
            OR statement LIKE N'%DELETE%['+N'dbo'+'].['+N'INS_GDV_GeneriqueDevises'+']%' ) )
),
ADD EVENT sqlserver.rpc_completed(
    ACTION(sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.database_name,
           sqlserver.session_id,sqlserver.username)
    WHERE ( sqlserver.database_name = DB_NAME()
         AND statement LIKE N'%['+N'dbo'+'].['+N'INS_GDV_GeneriqueDevises'+']%' )
),
ADD EVENT sqlserver.sql_batch_completed(
    ACTION(sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.database_name,
           sqlserver.session_id,sqlserver.username)
    WHERE ( sqlserver.database_name = DB_NAME()
         AND statement LIKE N'%['+N'dbo'+'].['+N'INS_GDV_GeneriqueDevises'+']%' )
)
ADD TARGET package0.event_file(
    SET filename=N'D:\SqlAudit\WhoWrites_INS_GDV_GeneriqueDevises.xel',
        max_file_size=(50),          -- 50 Mo par fichier
        max_rollover_files=(10)      -- ~500 Mo au total
);
GO

-- D√©marrer
ALTER EVENT SESSION [WhoWrites_INS_GDV_GeneriqueDevises] ON SERVER STATE = START;


Tu peux laisser tourner en continu. Les fichiers se rouleront (ici 10 √ó 50 Mo max).

‚∏ª

2) Lecture des fichiers .xel

-- Adapter le chemin si besoin (utiliser le m√™me dossier que ci-dessus)
;WITH X AS (
    SELECT CONVERT(xml, event_data) AS x
    FROM sys.fn_xe_file_target_read_file(
           N'D:\SqlAudit\WhoWrites_INS_GDV_GeneriqueDevises*.xel', NULL, NULL, NULL)
)
SELECT
  DATEADD(minute, DATEDIFF(minute, GETUTCDATE(), SYSUTCDATETIME()),
          X.x.value('(event/@timestamp)[1]','datetime2'))              AS event_time,
  X.x.value('(event/action[@name="username"]/value)[1]','sysname')    AS login_name,
  X.x.value('(event/action[@name="client_hostname"]/value)[1]','nvarchar(128)') AS host_name,
  X.x.value('(event/action[@name="client_app_name"]/value)[1]','nvarchar(128)') AS app_name,
  X.x.value('(event/action[@name="session_id"]/value)[1]','int')      AS session_id,
  COALESCE(
    X.x.value('(event/data[@name="statement"]/value)[1]','nvarchar(max)'),
    X.x.value('(event/data[@name="batch_text"]/value)[1]','nvarchar(max)')
  ) AS sql_text,
  X.x.value('(event/@name)[1]','nvarchar(64)')                         AS event_name
FROM X
ORDER BY event_time DESC;

3) Arr√™ter / supprimer (quand tu as identifi√© la source)

ALTER EVENT SESSION [WhoWrites_INS_GDV_GeneriqueDevises] ON SERVER STATE = STOP;
DROP EVENT SESSION  [WhoWrites_INS_GDV_GeneriqueDevises] ON SERVER;





Trouver dans le journal des transactions qui a modifi√© r√©cemment


-- >>> A D A P T E R <<<
DECLARE @schema sysname = N'dbo';
DECLARE @table  sysname = N'test1';

;WITH AU AS (  -- toutes les AU li√©es √† la table (row/LOB/overflow)
    SELECT au.allocation_unit_id
    FROM sys.partitions p
    JOIN sys.allocation_units au
         ON au.container_id IN (p.hobt_id, p.partition_id)
    WHERE p.object_id = OBJECT_ID(QUOTENAME(@schema)+'.'+QUOTENAME(@table))
),
L AS (  -- journal brut
    SELECT * FROM sys.fn_dblog(NULL,NULL)
),
O AS (  -- op√©rations qui touchent la table
    SELECT
        [Transaction ID]     AS tran_id,
        [Operation],
        [Context],
        [AllocUnitId],
        [AllocUnitName],
        [Page ID],
        [Slot ID]
    FROM L
    WHERE [AllocUnitId] IN (SELECT allocation_unit_id FROM AU)
      AND [Operation] IN ('LOP_INSERT_ROWS','LOP_MODIFY_ROW','LOP_DELETE_ROWS')
),
B AS (  -- d√©but de transaction
    SELECT
        [Transaction ID]                 AS tran_id,
        CONVERT(datetime,[Begin Time])   AS begin_time,
        [SPID]                           AS session_id,
        SUSER_SNAME([Transaction SID])   AS login_name,
        [Transaction Name]               AS tran_name
    FROM L
    WHERE [Operation] = 'LOP_BEGIN_XACT'
),
C AS (  -- commit (optionnel)
    SELECT
        [Transaction ID]                 AS tran_id,
        CONVERT(datetime,[End Time])     AS end_time
    FROM L
    WHERE [Operation] = 'LOP_COMMIT_XACT'
)
SELECT TOP (200)
    B.begin_time,
    C.end_time,
    B.login_name,
    B.session_id,
    B.tran_name,
    O.Operation, O.Context,
    O.AllocUnitName,
    O.[Page ID], O.[Slot ID],
    O.tran_id
FROM O
LEFT JOIN B ON B.tran_id = O.tran_id
LEFT JOIN C ON C.tran_id = O.tran_id
ORDER BY B.begin_time DESC, O.tran_id, O.Operation;



Tracer √† partir de maintenant (l√©ger) avec Extended Events

-- üîß A adapter : sch√©ma/table + chemin de fichier cible
DECLARE @schema sysname = N'dbo';
DECLARE @table  sysname = N'TaTable';

IF EXISTS (SELECT 1 FROM sys.server_event_sessions WHERE name = 'WhoWritesMyTable')
    DROP EVENT SESSION WhoWritesMyTable ON SERVER;
GO
CREATE EVENT SESSION WhoWritesMyTable ON SERVER
ADD EVENT sqlserver.sql_statement_completed(
    ACTION(sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.username,sqlserver.database_name,sqlserver.session_id)
    WHERE (sqlserver.database_name = DB_NAME()
       AND (statement LIKE '%INSERT%['+@schema+'].['+@table+']%'
         OR statement LIKE '%UPDATE%['+@schema+'].['+@table+']%'
         OR statement LIKE '%DELETE%['+@schema+'].['+@table+']%'))),
ADD EVENT sqlserver.rpc_completed(
    ACTION(sqlserver.client_app_name,sqlserver.client_hostname,sqlserver.username,sqlserver.database_name,sqlserver.session_id)
    WHERE (sqlserver.database_name = DB_NAME()
       AND statement LIKE '%['+@schema+'].['+@table+']%'))
ADD TARGET package0.event_file(SET filename=N'C:\Temp\WhoWritesMyTable.xel', max_file_size=(50), max_rollover_files=(4));
GO
ALTER EVENT SESSION WhoWritesMyTable ON SERVER STATE = START;

lire ensuite

SELECT
    DATEADD(hh, DATEDIFF(hh, GETUTCDATE(), SYSDATETIME()), event_data.value('(event/@timestamp)[1]', 'datetime2')) AS event_time,
    event_data.value('(event/action[@name="username"]/value)[1]','sysname')      AS login_name,
    event_data.value('(event/action[@name="client_hostname"]/value)[1]','nvarchar(128)') AS host_name,
    event_data.value('(event/action[@name="client_app_name"]/value)[1]','nvarchar(128)') AS app_name,
    event_data.value('(event/action[@name="session_id"]/value)[1]','int')        AS session_id,
    event_data.value('(event/data[@name="statement"]/value)[1]','nvarchar(max)') AS sql_text,
    event_data.value('(event/@name)[1]','nvarchar(100)')                          AS event_name
FROM (
    SELECT CONVERT(xml, event_data) AS event_data
    FROM sys.fn_xe_file_target_read_file('C:\Temp\WhoWritesMyTable*.xel', NULL, NULL, NULL)
) x
ORDER BY event_time DESC;


4) Audit SQL Server (persistant, propre, peu intrusif)

Audite sp√©cifiquement INSERT/UPDATE/DELETE sur ta table vers un fichier.

-- üîß Chemin √† adapter
IF NOT EXISTS (SELECT 1 FROM sys.server_audits WHERE name = 'Audit_DML_Table')
    CREATE SERVER AUDIT Audit_DML_Table
    TO FILE (FILEPATH = N'C:\Temp\AuditDML\')
    WITH (QUEUE_DELAY = 1000, ON_FAILURE = CONTINUE);
ALTER SERVER AUDIT Audit_DML_Table WITH (STATE = ON);
GO

IF EXISTS (SELECT 1 FROM sys.database_audit_specifications WHERE name = 'Audit_DML_Table_Spec')
    DROP DATABASE AUDIT SPECIFICATION Audit_DML_Table_Spec;
GO
CREATE DATABASE AUDIT SPECIFICATION Audit_DML_Table_Spec
FOR SERVER AUDIT Audit_DML_Table
    ADD (INSERT ON OBJECT::dbo.TaTable BY PUBLIC),
    ADD (UPDATE ON OBJECT::dbo.TaTable BY PUBLIC),
    ADD (DELETE ON OBJECT::dbo.TaTable BY PUBLIC);
ALTER DATABASE AUDIT SPECIFICATION Audit_DML_Table_Spec WITH (STATE = ON);
GO


 lire l'audit

SELECT
    event_time, action_id, succeeded, session_server_principal_name AS login_name,
    server_principal_name, database_principal_name,
    statement, object_name, schema_name, client_ip, application_name
FROM sys.fn_get_audit_file('C:\Temp\AuditDML\*.sqlaudit', DEFAULT, DEFAULT)
ORDER BY event_time DESC;




SET NOCOUNT ON;

DECLARE @db SYSNAME, @sql NVARCHAR(MAX);

DECLARE db_cursor CURSOR FOR
SELECT name
FROM sys.databases
WHERE state = 0  -- seulement les bases online
  AND database_id > 4; -- exclure master, model, msdb, tempdb

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @db;

WHILE @@FETCH_STATUS = 0
BEGIN
    PRINT '=== Checking database: ' + @db;

    SET @sql = N'
    USE [' + QUOTENAME(@db) + N'];

    -- Orphan users
    SELECT dp.name AS UserName,
           dp.sid  AS UserSID
    INTO #tmpOrphans
    FROM sys.database_principals dp
    LEFT JOIN sys.server_principals sp ON dp.sid = sp.sid
    WHERE dp.type_desc = ''SQL_USER''
      AND dp.principal_id > 4
      AND sp.sid IS NULL;

    DECLARE @User SYSNAME, @cmd NVARCHAR(MAX);

    DECLARE c CURSOR FOR SELECT UserName FROM #tmpOrphans;
    OPEN c;
    FETCH NEXT FROM c INTO @User;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        IF EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @User)
        BEGIN
            SET @cmd = N''ALTER USER ['' + @User + N''] WITH LOGIN = ['' + @User + N''];'';
            PRINT ''[' + @db + '] Fixing orphan user: '' + @User;
            EXEC (@cmd);
        END
        ELSE
        BEGIN
            SET @cmd = N''DROP USER ['' + @User + N''];'';
            PRINT ''[' + @db + '] Removing orphan user: '' + @User;
            BEGIN TRY
                EXEC (@cmd);
            END TRY
            BEGIN CATCH
                PRINT ''[ERROR] Could not drop user '' + @User + '': '' + ERROR_MESSAGE();
            END CATCH;
        END

        FETCH NEXT FROM c INTO @User;
    END

    CLOSE c;
    DEALLOCATE c;

    DROP TABLE #tmpOrphans;
    ';

    EXEC sys.sp_executesql @sql;

    FETCH NEXT FROM db_cursor INTO @db;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;





*********^

DECLARE @dbName NVARCHAR(128);
DECLARE @sql NVARCHAR(MAX);

DECLARE db_cursor CURSOR FOR
SELECT name
FROM sys.databases
WHERE state_desc = 'ONLINE'
  AND name NOT IN ('tempdb'); -- tu peux en ajouter d'autres √† exclure

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @dbName;

WHILE @@FETCH_STATUS = 0
BEGIN
    PRINT '===========================';
    PRINT ' V√©rification dans : ' + @dbName;
    PRINT '===========================';

    SET @sql = '
    USE [' + @dbName + '];
    SELECT ''' + @dbName + ''' AS database_name, name AS partition_scheme_name
    FROM sys.partition_schemes;
    ';

    EXEC sp_executesql @sql;

    FETCH NEXT FROM db_cursor INTO @dbName;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;








DECLARE @dbName NVARCHAR(128);
DECLARE @sql NVARCHAR(MAX);

DECLARE db_cursor CURSOR FOR
SELECT name
FROM sys.databases
WHERE state_desc = 'ONLINE'
  AND name NOT IN ('tempdb'); -- facultatif : exclure tempdb

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @dbName;

WHILE @@FETCH_STATUS = 0
BEGIN
    PRINT '====================================================';
    PRINT 'üîç V√©rification partitionnement dans la base : ' + @dbName;
    PRINT '====================================================';

    SET @sql = '
    USE [' + @dbName + '];

    SELECT 
        DB_NAME() AS database_name,
        o.name AS object_name,
        o.type_desc,
        i.name AS index_name,
        ps.name AS partition_scheme
    FROM sys.indexes i
    JOIN sys.partition_schemes ps ON i.data_space_id = ps.data_space_id
    JOIN sys.objects o ON i.object_id = o.object_id
    WHERE o.is_ms_shipped = 0
    ORDER BY o.name;
    ';

    EXEC sp_executesql @sql;

    FETCH NEXT FROM db_cursor INTO @dbName;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;




XDATLWBSA0001
XDATLWCOG0003
XDATLWESG0001
XDATLWIFA0001
XDATLWLGW0001
XDATLWMUT0042
XDATLWPAD0001
XDATLWZEM0105

votre l'utilisateur de la m√©moire 

-- Utilisation m√©moire par SQL Server
SELECT 
    physical_memory_in_use_kb / 1024 AS memory_used_MB,
    large_page_allocations_kb / 1024 AS large_page_MB,
    locked_page_allocations_kb / 1024 AS locked_page_MB,
    total_virtual_address_space_kb / 1024 AS total_VAS_MB
FROM sys.dm_os_process_memory;



analyse utilisation des fichiers en IO

Tu identifies rapidement les fichiers les plus lents (ceux tout en haut).
	‚Ä¢	Si tempdb ou une base critique est en haut de liste avec des temps >10ms en moyenne, c‚Äôest un signal d‚Äôalerte.

SELECT 
    DB_NAME(vfs.database_id) AS database_name,
    mf.name AS file_name,
    mf.type_desc AS file_type,
    vfs.num_of_reads,
    vfs.num_of_writes,
    vfs.io_stall_read_ms,
    vfs.io_stall_write_ms,
    vfs.io_stall_read_ms + vfs.io_stall_write_ms AS total_stall_ms,
    CASE 
        WHEN vfs.num_of_reads = 0 THEN NULL
        ELSE CONVERT(DECIMAL(10,2), vfs.io_stall_read_ms * 1.0 / vfs.num_of_reads)
    END AS avg_read_latency_ms,
    CASE 
        WHEN vfs.num_of_writes = 0 THEN NULL
        ELSE CONVERT(DECIMAL(10,2), vfs.io_stall_write_ms * 1.0 / vfs.num_of_writes)
    END AS avg_write_latency_ms,
    CASE 
        WHEN (vfs.num_of_reads + vfs.num_of_writes) = 0 THEN NULL
        ELSE CONVERT(DECIMAL(10,2), (vfs.io_stall_read_ms + vfs.io_stall_write_ms) * 1.0 / (vfs.num_of_reads + vfs.num_of_writes))
    END AS avg_io_latency_ms
FROM 
    sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
JOIN 
    sys.master_files AS mf 
    ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
ORDER BY 
    avg_io_latency_ms DESC;


Colonne
Description
avg_read_latency_ms
Temps moyen d‚Äôattente pour une lecture.
avg_write_latency_ms
Temps moyen d‚Äôattente pour une √©criture.
avg_io_latency_ms
Temps moyen global par op√©ration I/O (lecture ou √©criture).
total_stall_ms
Temps total pass√© en attente (latence cumul√©e).





DECLARE @LoginName SYSNAME = 'oddo\xdat_x_dbm_1';  


IF OBJECT_ID('tempdb..#UserMappings') IS NOT NULL
    DROP TABLE #UserMappings;

CREATE TABLE #UserMappings (
    DatabaseName SYSNAME,
    IsMapped BIT,
    UserName SYSNAME NULL,
    UserType VARCHAR(100) NULL
);

DECLARE @DBName SYSNAME;
DECLARE @SQL NVARCHAR(MAX);

DECLARE db_cursor CURSOR FOR 
SELECT name 
FROM sys.databases 
WHERE state_desc = 'ONLINE' AND name NOT IN ('tempdb');

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @DBName;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @SQL = '
    DECLARE @SID VARBINARY(85) = SUSER_SID(@LoginName);
    USE ' + QUOTENAME(@DBName) + ';
    IF EXISTS (
        SELECT 1 FROM sys.database_principals WHERE sid = @SID
    )
    BEGIN
        INSERT INTO #UserMappings (DatabaseName, IsMapped, UserName, UserType)
        SELECT 
            DB_NAME(),
            1,
            name,
            type_desc
        FROM sys.database_principals
        WHERE sid = @SID;
    END
    ELSE
    BEGIN
        INSERT INTO #UserMappings (DatabaseName, IsMapped, UserName, UserType)
        VALUES (DB_NAME(), 0, NULL, NULL);
    END
    ';

    EXEC sp_executesql @SQL, N'@LoginName SYSNAME', @LoginName;

    FETCH NEXT FROM db_cursor INTO @DBName;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;


SELECT * FROM #UserMappings ORDER BY DatabaseName;

DROP TABLE #UserMappings;


taux d'occupation filegroup

USE [NomDeVotreBase]; -- Remplacez par le nom de votre base de donn√©es
GO

SELECT 
    fg.name AS FilegroupName,
    df.name AS FileName,
    df.physical_name,
    df.size * 8.0 / 1024 AS SizeMB,
    FILEPROPERTY(df.name, 'SpaceUsed') * 8.0 / 1024 AS UsedSpaceMB,
    CAST(
        (FILEPROPERTY(df.name, 'SpaceUsed') * 1.0) / NULLIF(df.size, 0) * 100 
        AS DECIMAL(5,2)
    ) AS UsagePercent
FROM 
    sys.filegroups AS fg
JOIN 
    sys.database_files AS df ON fg.data_space_id = df.data_space_id
WHERE 
    df.type_desc = 'ROWS';








Voici un script PowerShell qui :
	1.	Lit une liste d‚Äôinstances SQL Server depuis un fichier texte ou une variable.
	2.	Se connecte √† chaque instance.
	3.	Supprime un login Active Directory sp√©cifique, s‚Äôil existe.

‚∏ª

üîß Pr√©requis
	‚Ä¢	PowerShell avec le module SqlServer install√© (Install-Module SqlServer si besoin).
	‚Ä¢	Droits suffisants pour supprimer des logins sur les instances SQL Server.
	‚Ä¢	Le compte doit √™tre un login sur chaque instance avec le droit ALTER ANY LOGIN.


# Sp√©cifiez ici le nom du login AD √† supprimer
$adLoginToRemove = "DOMAIN\\nom.utilisateur"

# Liste des instances SQL Server (vous pouvez aussi la charger depuis un fichier)
$sqlInstances = @(
    "SERVEUR1\INSTANCE1",
    "SERVEUR2",
    "SERVEUR3\INSTANCE2"
)

# Parcours des instances
foreach ($instance in $sqlInstances) {
    Write-Host "`nConnexion √† l'instance $instance..."

    try {
        # V√©rifie si le login existe
        $checkLoginQuery = @"
IF EXISTS (SELECT 1 FROM sys.server_principals WHERE name = N'$adLoginToRemove')
    SELECT 1 AS LoginExists
ELSE
    SELECT 0 AS LoginExists
"@

        $loginExists = Invoke-Sqlcmd -ServerInstance $instance -Query $checkLoginQuery

        if ($loginExists.LoginExists -eq 1) {
            Write-Host "‚Üí Le login '$adLoginToRemove' existe. Suppression en cours..."

            $dropLoginQuery = "DROP LOGIN [$adLoginToRemove]"

            Invoke-Sqlcmd -ServerInstance $instance -Query $dropLoginQuery
            Write-Host "‚úîÔ∏è Login supprim√© avec succ√®s de $instance"
        } else {
            Write-Host "‚ÑπÔ∏è Le login '$adLoginToRemove' n'existe pas sur $instance"
        }
    }
    catch {
        Write-Warning "‚ö†Ô∏è Erreur lors du traitement de l'instance $instance : $_"
    }
}



Notes
	‚Ä¢	Si tu veux lire les instances depuis un fichier texte (par ex. instances.txt), remplace cette ligne :


$sqlInstances = @(

par

$sqlInstances = Get-Content -Path "C:\chemin\vers\instances.txt"


	‚Ä¢	Le login doit √™tre au format DOMAIN\utilisateur.






Pour ex√©cuter nimporte quel query sur une liste de server

Script PowerShell : ex√©cution de requ√™te sur toutes les instances

# Chemin vers le fichier contenant la liste des instances SQL Server
$instanceListPath = "C:\chemin\vers\instances.txt"

# Charger les instances SQL
$sqlInstances = Get-Content -Path $instanceListPath

# Sp√©cifiez ici votre requ√™te SQL √† ex√©cuter
$queryToRun = @"
-- Exemple : afficher les bases de donn√©es
SELECT name, state_desc FROM sys.databases
"@

# Boucle sur chaque instance
foreach ($instance in $sqlInstances) {
    Write-Host "`nConnexion √† l'instance $instance..."

    try {
        # Ex√©cution de la requ√™te
        $results = Invoke-Sqlcmd -ServerInstance $instance -Query $queryToRun -ErrorAction Stop

        if ($results) {
            Write-Host "‚úîÔ∏è R√©sultats depuis $instance :"
            $results | Format-Table -AutoSize
        } else {
            Write-Host "‚ÑπÔ∏è Aucune donn√©e retourn√©e par $instance"
        }
    }
    catch {
        Write-Warning "‚ö†Ô∏è Erreur sur l'instance $instance : $_"
    }
}




pour sauvegarder le fichier

$results | Export-Csv -Path "C:\temp\resultats_$($instance -replace '\\', '_').csv" -NoTypeInformation


exemple de query a changer

$queryToRun = "SELECT @@VERSION AS Version"






autre script pour supprimer les login


# Chemin vers le fichier contenant la liste des instances SQL Server
$instanceListPath = "C:\chemin\vers\instances.txt"

# Charger les instances SQL
$sqlInstances = Get-Content -Path $instanceListPath

# Login AD √† supprimer (√©chapp√© correctement pour T-SQL)
$loginToDrop = "DOMAIN\\nom.utilisateur"

# Requ√™te compl√®te : v√©rifie d'abord si le login existe avant de le supprimer
$queryToRun = @"
IF EXISTS (SELECT 1 FROM sys.server_principals WHERE name = N'$loginToDrop')
BEGIN
    DROP LOGIN [$loginToDrop]
    PRINT 'Login supprim√©.'
END
ELSE
BEGIN
    PRINT 'Login non trouv√©.'
END
"@

# Ex√©cution sur chaque instance
foreach ($instance in $sqlInstances) {
    Write-Host "`nConnexion √† $instance..."

    try {
        $result = Invoke-Sqlcmd -ServerInstance $instance -Query $queryToRun -ErrorAction Stop
        Write-Host "‚úîÔ∏è $instance :"
        $result | ForEach-Object { Write-Host $_ }
    }
    catch {
        Write-Warning "‚ö†Ô∏è Erreur sur $instance : $_"
    }
}

Ce que fait ce script
	‚Ä¢	‚úÖ V√©rifie l‚Äôexistence du login sur chaque instance.
	‚Ä¢	‚úÖ Le supprime uniquement s‚Äôil est pr√©sent.
	‚Ä¢	‚úÖ Affiche un message clair (Login supprim√©. ou Login non trouv√©.).
	‚Ä¢	‚ùå √âvite les erreurs T-SQL si le login est absent.


voir les session

SELECT 
    s.session_id,
    r.request_id,
    s.login_name,
    s.host_name,
    s.program_name,
    r.status,
    r.command,
    r.start_time,
    r.cpu_time,
    r.total_elapsed_time / 1000.0 AS elapsed_seconds,
    r.memory_usage * 8 AS memory_usage_MB,
    t.text AS sql_text
FROM sys.dm_exec_sessions s
JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
ORDER BY r.memory_usage DESC

WHERE s.session_id = 143,



 voir si un plan d'ex√©cution forc√© a echou√©

SELECT 
    qsp.query_id,
    qsp.plan_id,
    qsp.is_forced_plan,
    qsp.is_forced_plan_failed,
    qsqt.query_sql_text,
    qsp.last_execution_time
FROM sys.query_store_plan qsp
JOIN sys.query_store_query qsq ON qsp.query_id = qsq.query_id
JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id
WHERE qsp.is_forced_plan = 1;

Si is_forced_plan_failed = 1 ‚Üí le plan a √©chou√©.












-- 1. V√©rification des fonctionnalit√©s Enterprise utilis√©es (globales)
SELECT 
    feature_name,
    feature_id,
    usage_count,
    last_usage_time
FROM 
    sys.dm_db_persisted_sku_features;

-- 2. Bases de donn√©es utilisant TDE (Transparent Data Encryption)
SELECT 
    name AS DatabaseName,
    is_encrypted
FROM 
    sys.databases
WHERE 
    is_encrypted = 1;

-- 3. Index Columnstore (Enterprise uniquement dans certaines versions)
EXEC sp_MSforeachdb '
USE [?];
SELECT 
    DB_NAME() AS DatabaseName,
    OBJECT_NAME(object_id) AS TableName,
    name AS IndexName,
    type_desc
FROM 
    sys.indexes 
WHERE 
    type_desc LIKE ''%COLUMNSTORE%''';

-- 4. Compression de donn√©es utilis√©e sur les index
EXEC sp_MSforeachdb '
USE [?];
SELECT 
    DB_NAME() AS DatabaseName,
    OBJECT_NAME(i.object_id) AS TableName,
    i.name AS IndexName,
    p.data_compression_desc
FROM 
    sys.partitions p
JOIN 
    sys.indexes i ON p.object_id = i.object_id AND p.index_id = p.index_id
WHERE 
    p.data_compression <> 0';

-- 5. Tables partitionn√©es
EXEC sp_MSforeachdb '
USE [?];
SELECT 
    DB_NAME() AS DatabaseName,
    name AS TableName
FROM 
    sys.tables 
WHERE 
    is_ms_shipped = 0 AND is_partitioned = 1';

-- 6. In-Memory OLTP utilis√©
EXEC sp_MSforeachdb '
USE [?];
IF EXISTS (SELECT * FROM sys.tables WHERE is_memory_optimized = 1)
BEGIN
    SELECT 
        DB_NAME() AS DatabaseName,
        name AS TableName,
        durability_desc
    FROM 
        sys.memory_optimized_tables_internal_attributes;
END';

-- 7. Change Data Capture (CDC) utilis√©
EXEC sp_MSforeachdb '
USE [?];
IF EXISTS (SELECT * FROM sys.tables WHERE is_tracked_by_cdc = 1)
BEGIN
    SELECT 
        DB_NAME() AS DatabaseName,
        name AS TableName
    FROM 
        sys.tables 
    WHERE 
        is_tracked_by_cdc = 1;
END';







-- 1. Fonctionnalit√©s Enterprise d√©tect√©es par SQL Server
SELECT 
    feature_name,
    feature_id
FROM 
    sys.dm_db_persisted_sku_features;

-- 2. Bases avec TDE activ√© (Transparent Data Encryption)
SELECT 
    name AS DatabaseName,
    is_encrypted
FROM 
    sys.databases
WHERE 
    is_encrypted = 1;

-- 3. Recherche d‚Äôindex COLUMNSTORE
EXEC sp_MSforeachdb '
USE [?];
IF DB_ID(''?'') NOT IN (1,2,3,4)
BEGIN
    SELECT 
        DB_NAME() AS DatabaseName,
        OBJECT_NAME(object_id) AS TableName,
        name AS IndexName,
        type_desc
    FROM 
        sys.indexes
    WHERE 
        type_desc LIKE ''%COLUMNSTORE%''
        AND OBJECTPROPERTY(object_id, ''IsMsShipped'') = 0;
END
';

-- 4. V√©rification de la compression utilis√©e
EXEC sp_MSforeachdb '
USE [?];
IF DB_ID(''?'') NOT IN (1,2,3,4)
BEGIN
    SELECT 
        DB_NAME() AS DatabaseName,
        OBJECT_NAME(p.object_id) AS TableName,
        i.name AS IndexName,
        p.data_compression_desc
    FROM 
        sys.partitions p
    JOIN 
        sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id
    WHERE 
        p.data_compression IN (1, 2) -- 1 = ROW, 2 = PAGE
        AND OBJECTPROPERTY(p.object_id, ''IsMsShipped'') = 0;
END
';

-- 5. Tables partitionn√©es
EXEC sp_MSforeachdb '
USE [?];
IF DB_ID(''?'') NOT IN (1,2,3,4)
BEGIN
    SELECT 
        DB_NAME() AS DatabaseName,
        name AS TableName
    FROM 
        sys.tables
    WHERE 
        is_partitioned = 1
        AND is_ms_shipped = 0;
END
';

-- 6. In-Memory OLTP (Memory-Optimized Tables)
EXEC sp_MSforeachdb '
USE [?];
IF EXISTS (
    SELECT 1 FROM sys.tables WHERE is_memory_optimized = 1
)
BEGIN
    SELECT 
        DB_NAME() AS DatabaseName,
        name AS TableName
    FROM 
        sys.tables
    WHERE 
        is_memory_optimized = 1;
END
';

-- 7. CDC activ√© (Change Data Capture)
EXEC sp_MSforeachdb '
USE [?];
IF EXISTS (
    SELECT 1 FROM sys.tables WHERE is_tracked_by_cdc = 1
)
BEGIN
    SELECT 
        DB_NAME() AS DatabaseName,
        name AS TableName
    FROM 
        sys.tables
    WHERE 
        is_tracked_by_cdc = 1;
END
';




voir lez objets partitioner 

EXEC sp_MSforeachdb '
USE [?];
IF DB_ID(''?'') NOT IN (1,2,3,4)
BEGIN
    SELECT 
        DB_NAME() AS DatabaseName,
        t.name AS TableName,
        i.name AS IndexName,
        ps.name AS PartitionScheme
    FROM 
        sys.indexes i
    INNER JOIN 
        sys.tables t ON i.object_id = t.object_id
    INNER JOIN 
        sys.data_spaces ds ON i.data_space_id = ds.data_space_id
    LEFT JOIN 
        sys.partition_schemes ps ON ds.data_space_id = ps.data_space_id
    WHERE 
        ps.name IS NOT NULL
        AND t.is_ms_shipped = 0;
END
';

 voir la taille des fichiers bdd

SELECT 
    db.name AS database_name,
    mf.name AS logical_name,
    mf.physical_name,
    mf.type_desc,
    CAST(mf.size * 8.0 / 1024 / 1024 AS DECIMAL(10,2)) AS size_GB
FROM 
    sys.master_files mf
JOIN 
    sys.databases db ON db.database_id = mf.database_id
ORDER BY 
    db.name, mf.type_desc;




 r√©sum√© du tde

-- Liste des bases utilisant TDE
SELECT 
    name AS DatabaseName,
    is_encrypted
INTO #EncryptedDatabases
FROM 
    sys.databases
WHERE 
    is_encrypted = 1;

-- Afficher les certificats et types de chiffrement utilis√©s pour chaque base
DECLARE @dbName NVARCHAR(128);
DECLARE db_cursor CURSOR FOR
SELECT name FROM #EncryptedDatabases;

CREATE TABLE #TDE_Details (
    DatabaseName NVARCHAR(128),
    EncryptorType NVARCHAR(50),
    Thumbprint VARBINARY(64),
    CertificateName NVARCHAR(128)
);

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @dbName;

WHILE @@FETCH_STATUS = 0
BEGIN
    DECLARE @sql NVARCHAR(MAX);
    SET @sql = '
    USE [' + @dbName + '];
    INSERT INTO #TDE_Details (DatabaseName, EncryptorType, Thumbprint, CertificateName)
    SELECT 
        ''' + @dbName + ''' AS DatabaseName,
        dek.encryptor_type,
        dek.encryptor_thumbprint,
        cert.name
    FROM 
        sys.dm_database_encryption_keys dek
    LEFT JOIN 
        master.sys.certificates cert ON dek.encryptor_thumbprint = cert.thumbprint;
    ';
    EXEC (@sql);
    FETCH NEXT FROM db_cursor INTO @dbName;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;

-- R√©sultat combin√©
SELECT * FROM #TDE_Details;

-- Liste des certificats dans master
SELECT 
    name AS CertificateName,
    subject,
    expiry_date,
    thumbprint,
    pvt_key_encryption_type_desc
FROM 
    master.sys.certificates
WHERE 
    issuer_name IS NOT NULL;

-- Liste des cl√©s asym√©triques dans master
SELECT 
    name AS AsymKeyName,
    key_algorithm,
    key_length
FROM 
    master.sys.asymmetric_keys;

-- Liste des cl√©s sym√©triques dans master
SELECT 
    name AS SymKeyName,
    algorithm_desc,
    key_length
FROM 
    master.sys.symmetric_keys
WHERE 
    name != '##MS_DatabaseMasterKey##';

-- Nettoyage
DROP TABLE #EncryptedDatabases;
DROP TABLE #TDE_Details;



*****************************************


‚úÖ 1. Requ√™te pour voir les e-mails envoy√©s et leur statut

SELECT 
    mailitem.subject,
    mailitem.recipients,
    mailitem.body,
    mailitem.send_request_date,
    mailitem.sent_date,
    mailitem.last_mod_date,
    mailitem.sent_account_id,
    CASE
        WHEN mailitem.sent_status = 'sent' THEN '‚úÖ Succ√®s'
        WHEN mailitem.sent_status = 'failed' THEN '‚ùå √âchec'
        ELSE mailitem.sent_status
    END AS statut,
    log.description AS erreur_message
FROM msdb.dbo.sysmail_allitems AS mailitem
LEFT JOIN msdb.dbo.sysmail_event_log AS log
    ON mailitem.mailitem_id = log.mailitem_id
ORDER BY mailitem.send_request_date DESC;



2. Filtrer par statut si besoin
	‚Ä¢	Pour voir uniquement les mails √©chou√©s :


SELECT *
FROM msdb.dbo.sysmail_faileditems
ORDER BY send_request_date DESC;


Pour voir uniquement les mails r√©ussis :

SELECT *
FROM msdb.dbo.sysmail_sentitems
ORDER BY send_request_date DESC;


‚úÖ 3. Voir les logs d√©taill√©s Database Mail


SELECT *
FROM msdb.dbo.sysmail_event_log
ORDER BY log_date DESC;


Cela donne le d√©tail des erreurs si un mail √©choue (probl√®me SMTP, format, etc.).

‚∏ª

üìå Remarques
	‚Ä¢	Il faut que Database Mail soit activ√© (sysmail_enable) et configur√©.
	‚Ä¢	Les vues sont dans la base syst√®me msdb.



‚úÖ 1. V√©rifier si le service Database Mail est en cours d‚Äôex√©cution

EXEC msdb.dbo.sysmail_help_status_sp;


‚úÖ 2. D√©marrer le service si n√©cessaire

Si le statut est STOPPED, tu peux le d√©marrer manuellement :


EXEC msdb.dbo.sysmail_start_sp;

Et pour l‚Äôarr√™ter (utile en cas de maintenance) :

EXEC msdb.dbo.sysmail_stop_sp;



‚∏ª

‚úÖ 4. V√©rifier dans l‚Äôinterface SSMS (GUI)
	1.	Dans SSMS, ouvre ‚ÄúManagement‚Äù > ‚ÄúDatabase Mail‚Äù.
	2.	Clic droit > View Database Mail Log.
	3.	Tu verras les erreurs (SMTP, authentification, format, etc.).


