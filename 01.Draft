

analyse utilisation des fichiers en IO

Tu identifies rapidement les fichiers les plus lents (ceux tout en haut).
	‚Ä¢	Si tempdb ou une base critique est en haut de liste avec des temps >10ms en moyenne, c‚Äôest un signal d‚Äôalerte.

SELECT 
    DB_NAME(vfs.database_id) AS database_name,
    mf.name AS file_name,
    mf.type_desc AS file_type,
    vfs.num_of_reads,
    vfs.num_of_writes,
    vfs.io_stall_read_ms,
    vfs.io_stall_write_ms,
    vfs.io_stall_read_ms + vfs.io_stall_write_ms AS total_stall_ms,
    CASE 
        WHEN vfs.num_of_reads = 0 THEN NULL
        ELSE CONVERT(DECIMAL(10,2), vfs.io_stall_read_ms * 1.0 / vfs.num_of_reads)
    END AS avg_read_latency_ms,
    CASE 
        WHEN vfs.num_of_writes = 0 THEN NULL
        ELSE CONVERT(DECIMAL(10,2), vfs.io_stall_write_ms * 1.0 / vfs.num_of_writes)
    END AS avg_write_latency_ms,
    CASE 
        WHEN (vfs.num_of_reads + vfs.num_of_writes) = 0 THEN NULL
        ELSE CONVERT(DECIMAL(10,2), (vfs.io_stall_read_ms + vfs.io_stall_write_ms) * 1.0 / (vfs.num_of_reads + vfs.num_of_writes))
    END AS avg_io_latency_ms
FROM 
    sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
JOIN 
    sys.master_files AS mf 
    ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
ORDER BY 
    avg_io_latency_ms DESC;


Colonne
Description
avg_read_latency_ms
Temps moyen d‚Äôattente pour une lecture.
avg_write_latency_ms
Temps moyen d‚Äôattente pour une √©criture.
avg_io_latency_ms
Temps moyen global par op√©ration I/O (lecture ou √©criture).
total_stall_ms
Temps total pass√© en attente (latence cumul√©e).





DECLARE @LoginName SYSNAME = 'oddo\xdat_x_dbm_1';  


IF OBJECT_ID('tempdb..#UserMappings') IS NOT NULL
    DROP TABLE #UserMappings;

CREATE TABLE #UserMappings (
    DatabaseName SYSNAME,
    IsMapped BIT,
    UserName SYSNAME NULL,
    UserType VARCHAR(100) NULL
);

DECLARE @DBName SYSNAME;
DECLARE @SQL NVARCHAR(MAX);

DECLARE db_cursor CURSOR FOR 
SELECT name 
FROM sys.databases 
WHERE state_desc = 'ONLINE' AND name NOT IN ('tempdb');

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @DBName;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @SQL = '
    DECLARE @SID VARBINARY(85) = SUSER_SID(@LoginName);
    USE ' + QUOTENAME(@DBName) + ';
    IF EXISTS (
        SELECT 1 FROM sys.database_principals WHERE sid = @SID
    )
    BEGIN
        INSERT INTO #UserMappings (DatabaseName, IsMapped, UserName, UserType)
        SELECT 
            DB_NAME(),
            1,
            name,
            type_desc
        FROM sys.database_principals
        WHERE sid = @SID;
    END
    ELSE
    BEGIN
        INSERT INTO #UserMappings (DatabaseName, IsMapped, UserName, UserType)
        VALUES (DB_NAME(), 0, NULL, NULL);
    END
    ';

    EXEC sp_executesql @SQL, N'@LoginName SYSNAME', @LoginName;

    FETCH NEXT FROM db_cursor INTO @DBName;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;


SELECT * FROM #UserMappings ORDER BY DatabaseName;

DROP TABLE #UserMappings;


taux d'occupation filegroup

USE [NomDeVotreBase]; -- Remplacez par le nom de votre base de donn√©es
GO

SELECT 
    fg.name AS FilegroupName,
    df.name AS FileName,
    df.physical_name,
    df.size * 8.0 / 1024 AS SizeMB,
    FILEPROPERTY(df.name, 'SpaceUsed') * 8.0 / 1024 AS UsedSpaceMB,
    CAST(
        (FILEPROPERTY(df.name, 'SpaceUsed') * 1.0) / NULLIF(df.size, 0) * 100 
        AS DECIMAL(5,2)
    ) AS UsagePercent
FROM 
    sys.filegroups AS fg
JOIN 
    sys.database_files AS df ON fg.data_space_id = df.data_space_id
WHERE 
    df.type_desc = 'ROWS';








Voici un script PowerShell qui :
	1.	Lit une liste d‚Äôinstances SQL Server depuis un fichier texte ou une variable.
	2.	Se connecte √† chaque instance.
	3.	Supprime un login Active Directory sp√©cifique, s‚Äôil existe.

‚∏ª

üîß Pr√©requis
	‚Ä¢	PowerShell avec le module SqlServer install√© (Install-Module SqlServer si besoin).
	‚Ä¢	Droits suffisants pour supprimer des logins sur les instances SQL Server.
	‚Ä¢	Le compte doit √™tre un login sur chaque instance avec le droit ALTER ANY LOGIN.


# Sp√©cifiez ici le nom du login AD √† supprimer
$adLoginToRemove = "DOMAIN\\nom.utilisateur"

# Liste des instances SQL Server (vous pouvez aussi la charger depuis un fichier)
$sqlInstances = @(
    "SERVEUR1\INSTANCE1",
    "SERVEUR2",
    "SERVEUR3\INSTANCE2"
)

# Parcours des instances
foreach ($instance in $sqlInstances) {
    Write-Host "`nConnexion √† l'instance $instance..."

    try {
        # V√©rifie si le login existe
        $checkLoginQuery = @"
IF EXISTS (SELECT 1 FROM sys.server_principals WHERE name = N'$adLoginToRemove')
    SELECT 1 AS LoginExists
ELSE
    SELECT 0 AS LoginExists
"@

        $loginExists = Invoke-Sqlcmd -ServerInstance $instance -Query $checkLoginQuery

        if ($loginExists.LoginExists -eq 1) {
            Write-Host "‚Üí Le login '$adLoginToRemove' existe. Suppression en cours..."

            $dropLoginQuery = "DROP LOGIN [$adLoginToRemove]"

            Invoke-Sqlcmd -ServerInstance $instance -Query $dropLoginQuery
            Write-Host "‚úîÔ∏è Login supprim√© avec succ√®s de $instance"
        } else {
            Write-Host "‚ÑπÔ∏è Le login '$adLoginToRemove' n'existe pas sur $instance"
        }
    }
    catch {
        Write-Warning "‚ö†Ô∏è Erreur lors du traitement de l'instance $instance : $_"
    }
}



Notes
	‚Ä¢	Si tu veux lire les instances depuis un fichier texte (par ex. instances.txt), remplace cette ligne :


$sqlInstances = @(

par

$sqlInstances = Get-Content -Path "C:\chemin\vers\instances.txt"


	‚Ä¢	Le login doit √™tre au format DOMAIN\utilisateur.



